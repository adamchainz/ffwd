#!/usr/bin/env python
"""A reference tunneling proxy for EVD."""

import time
import base64
import json
import asyncore
import sys
import socket
import struct
import logging

log = logging.getLogger(__name__)

TEXT = object()
BINARY = object()
UDP = 'udp'
TCP = 'tcp'
RECV_MAX = 8192
DEFAULT_PROTOCOL = "text"
PROTOCOL_MAX_DATALEN = 2 ** 16


def protocol_ip(family, ip):
    if family == socket.AF_INET:
        return socket.inet_ntop(family, ip[:4])

    if family == socket.AF_INET6:
        return socket.inet_ntop(family, ip[:16])

    raise Exception("unsupported family: %s" % (family))


def protocol_type(protocol):
    if protocol == "text":
        return TEXT

    if protocol == "binary":
        return BINARY

    raise Exception("Unsupported protocol: %s" % (protocol))


class _TunnelBindUDP(asyncore.dispatcher):
    def __init__(self, tunnel, bindport):
        asyncore.dispatcher.__init__(self)
        self.create_socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.set_reuse_addr()
        self.bind(('127.0.0.1', bindport))

        self._tunnel = tunnel
        self._bindport = bindport

    def handle_read(self):
        """implement asyncore.dispatcher#handle_read"""
        data, addr = self.recvfrom(RECV_MAX)
        addr = (self.family, addr[0], addr[1])
        self._tunnel.receive_client_data(
            socket.SOCK_DGRAM, self._bindport, addr, data)

    def tunnel_send_data(self, addr, data):
        family, addr, port = addr
        self.sendto(data, (addr, port))


class _TunnelBindTCP(asyncore.dispatcher):
    class Connection(asyncore.dispatcher_with_send):
        def __init__(self, tunnel, sock, addr):
            asyncore.dispatcher_with_send.__init__(self, sock)
            self.tunnel = tunnel
            self.addr = addr

        def handle_close(self):
            """implement asyncore.dispatcher_with_send#handle_close."""
            self.tunnel.connection_close(self.addr)

        def handle_error(self):
            """implement asyncore.dispatcher_with_send#handle_error."""
            self.tunnel.connection_close(self.addr)

        def handle_read(self):
            """implement asyncore.dispatcher#handle_read."""
            self.tunnel.client_receive_data(self.addr, self.recv(RECV_MAX))

    def __init__(self, tunnel, bindport):
        asyncore.dispatcher.__init__(self)
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.set_reuse_addr()
        self.bind(('127.0.0.1', bindport))
        self.listen(5)

        self._tunnel = tunnel
        self._bindport = bindport
        self._connections = dict()

    def client_receive_data(self, addr, data):
        """Receive data from TCP connections."""

        if len(data) > 0:
            self._tunnel.receive_client_data(
                socket.SOCK_STREAM, self._bindport, addr, data)

    def handle_close(self):
        """implement asyncore.dispatcher#handle_close."""
        self.close()

    def handle_accept(self):
        """implement asyncore.dispatcher#handle_accept."""
        pair = self.accept()

        if pair is not None:
            sock, addr = pair
            addr = (sock.family, addr[0], addr[1])
            self._connections[addr] = self.Connection(self, sock, addr)

    def connection_close(self, addr):
        """Remove the client connection associated with addr."""
        client = self._connections[addr]
        client.close()
        del self._connections[addr]

    def close(self):
        for client in self._connections.values():
            client.close()

        self._connections = {}
        asyncore.dispatcher.close(self)

    def tunnel_send_data(self, addr, data):
        try:
            client = self._connections[addr]
        except KeyError:
            log.error("no such client: %s", addr)
            return

        client.send(data)


class _LineProtocol(object):
    delimiter = '\n'

    def __init__(self):
        self._lp_buffer = ""
        self._lp_size = 0

    def set_mode(self, size):
        self._lp_size = size

    def handle_read(self):
        """implement asyncore.dispatcher#handle_read."""

        data = self.recv(RECV_MAX)

        if self._lp_size == 0:
            self._handle_line(data)
        else:
            self._handle_text(data)

    def _handle_line(self, data):
        while True:
            try:
                i = data.index(self.delimiter)
            except ValueError:
                break

            try:
                self.receive_line(self._lp_buffer + data[:i])
            except:
                log.error("receive_line failed", exc_info=sys.exc_info())

            self._lp_buffer = ""
            data = data[i + 2:]

        if len(data) > 0:
            self._lp_buffer += data

    def _handle_text(self, data):
        self._lp_buffer += data

        while len(self._lp_buffer) >= self._lp_size:
            size = self._lp_size
            self._lp_size = 0
            self.receive_text(self._lp_buffer[:size])
            self._lp_buffer = self._lp_buffer[size:]

    def send_line(self, line):
        """Send a line of data using the specified delimiter."""
        self.send(line + self.delimiter)


BIND_PROTOCOLS = {
    socket.SOCK_STREAM: _TunnelBindTCP,
    socket.SOCK_DGRAM: _TunnelBindUDP,
}


class _TunnelClient(_LineProtocol, asyncore.dispatcher_with_send):
    HEADER = struct.Struct("!BHB16sHH")

    def __init__(self, metadata, protocol=TCP):
        asyncore.dispatcher_with_send.__init__(self)
        _LineProtocol.__init__(self)

        if protocol == TCP:
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        else:
            self.create_socket(socket.AF_INET, socket.SOCK_DGRAM)

        self._protocol_type = None
        self._metadata = metadata
        self._config = None
        self._servers = dict()
        self._header = None

    def handle_error(self):
        """implement asyncore.dispatcher#handle_error."""
        exc_info = sys.exc_info()
        log.error("error: %s", str(exc_info[1]), exc_info=exc_info)
        self.close()

    def handle_close(self):
        """implement asyncore.dispatcher#handle_close."""
        log.info("closed")
        self.close()

    def close(self):
        for server in self._servers.values():
            server.close()

        self._servers = dict()
        self._config = None

        asyncore.dispatcher_with_send.close(self)

    def receive_client_data(self, protocol, bindport, addr, data):
        """Handle data received by a connected client."""

        try:
            if self._protocol_type == TEXT:
                return self._receive_text(protocol, bindport, addr, data)

            if self._protocol_type == BINARY:
                return self._receive_binary(protocol, bindport, addr, data)
        except:
            log.error("Failed to receive client data", exc_info=sys.exc_info())

    def _receive_text(self, protocol, bindport, addr, data):
        family = addr[0]
        ip = addr[1]
        port = addr[2]

        data = base64.b64encode(data)

        self.send_line("%d %d %d %s %d %s" % (
            protocol, bindport, family, ip, port, data))

    def _receive_binary(self, protocol, bindport, addr, data):
        family = addr[0]
        ip = socket.inet_pton(addr[0], addr[1])
        port = addr[2]
        datasize = len(data)

        if datasize > PROTOCOL_MAX_DATALEN:
            raise Exception("Maximum data length exceeded")

        header = self.HEADER.pack(
            protocol, bindport, family, ip, port, datasize)

        frame = header + data
        self.send(frame)

    def handle_connect(self):
        """implement asyncore.dispatcher#handle_connect."""
        log.info("connected")
        self.send_line(json.dumps(self._metadata))

    def receive_line(self, line):
        """implement _LineProtocol#receive_line."""
        if self._config is None:
            self._config = json.loads(line)
            log.info("CONFIG: %s", repr(self._config))

            self._protocol_type = protocol_type(
                self._config.get('type', DEFAULT_PROTOCOL))
            self._bind_all()

            if self._protocol_type == BINARY:
                self.set_mode(self.HEADER.size)

            return

        if self._protocol_type != TEXT:
            raise Exception("Received line but mode != text")

        self._text_protocol_read(line)

    def receive_text(self, data):
        if self._header is None:
            self._header = self.HEADER.unpack(data)
            self.set_mode(self._header[5])
            return

        protocol, bindport, family, ip, port, _ = self._header
        ip = protocol_ip(family, ip)

        server_id = (protocol, bindport)
        addr = (family, ip, port)
        self._send_frame(server_id, addr, data)

        self._header = None
        self.set_mode(self.HEADER.size)

    def _text_protocol_read(self, line):
        parts = line.split(' ', 6)
        protocol, bindport, family, ip, port, data = parts

        try:
            protocol = int(protocol)
            bindport = int(bindport)
            family = int(family)
            port = int(port)
            data = base64.b64decode(data)
        except:
            log.error("received invalid frame")
            return

        server_id = (protocol, bindport)
        addr = (family, ip, port)
        self._send_frame(server_id, addr, data)

    def _send_frame(self, server_id, addr, data):
        try:
            server = self._servers[server_id]
        except KeyError:
            log.error("no such server: %s", server_id)
            return

        server.tunnel_send_data(addr, data)

    def _bind_all(self):
        """Bind all protocol/port combinations from configuration."""
        bind = self._config.get('bind', [])

        for b in bind:
            server_id = (b['protocol'], b['port'])
            protocol, port = server_id

            if server_id in self._servers:
                log.error("already bound: %s", repr(server_id))
                continue

            try:
                server = BIND_PROTOCOLS[protocol](self, port)
                self._servers[server_id] = server
            except:
                log.error("failed to bind: %s", repr(b),
                          exc_info=sys.exc_info())
                continue

        if len(self._servers) != len(bind):
            log.error("unable to bind everything: %s", repr(bind))
            self.close()


def _main(args):
    logging.basicConfig(level=logging.INFO)

    if len(args) > 0:
        with open(args[0]) as f:
            metadata = json.load(f)
    else:
        metadata = dict()

    addr = ('127.0.0.1', 9000)

    reconnect_timeout = 1.0

    while True:
        client = _TunnelClient(metadata)
        client.connect(addr)

        asyncore.loop()

        log.info("reconnecting in %ds", reconnect_timeout)
        time.sleep(reconnect_timeout)

if __name__ == "__main__":
    sys.exit(_main(sys.argv[1:]))
